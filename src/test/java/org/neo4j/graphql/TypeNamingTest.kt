package org.neo4j.graphql

import org.junit.After
import org.junit.Before
import org.junit.Ignore
import org.junit.Test
import org.neo4j.graphql.TestUtil.assertResult
import org.neo4j.graphql.TestUtil.execute

/**
 * @author mh
 * *
 * @since 05.05.17
 */
class TypeNamingTest {
    @Before
    @Throws(Exception::class)
    fun setUp() {
    }

    @After
    @Throws(Exception::class)
    fun tearDown() {
        TestUtil.tearDown()
    }

    @Test @Ignore("Bug introduce BOTH relationship handling for generated graphs, esp in mergeRelationships")
    fun duplicatePropertyRelationshipBoth() {
        execute("CREATE (:Person {name:'Jane'})-[:KNOWS]->(:Person {name:'John'})")

        assertResult("""query { person { name, _knows { name } } }"""
            ,mapOf("person" to listOf(mapOf("name" to "Jane", "_knows" to listOf(mapOf("name" to "John"))), mapOf("name" to "John", "_knows" to emptyList<Map<String,Any>>()))))
    }
    @Test
    fun duplicatePropertyRelationship() {
        execute("CREATE (:Person {knows:'Jane'})-[:knows]->(:Friend {name:'John'}),(:Person {knows:'Alex'})")
        assertResult("""query { person { knows, _knows { name } } }""",
        mapOf("person" to listOf(mapOf("knows" to "Jane", "_knows" to mapOf("name" to "John")), mapOf("knows" to "Alex", "_knows" to null))))
    }

    @Test
    fun dynamicQueryTypeAccessAttributes() {
        val schema = """
type Order {
    sid: ID!
    name: String
    description: String
    date: Int
    position: [OrderPosition] @relation(name:"PART_OF",direction:"IN")
}

type OrderPosition {
    amount: Int
    order: Order @relation(name:"PART_OF")
    sid: ID!
}

schema {
   mutation: MutationType
   query: QueryType
}
type MutationType {
    setOrderPositionAmount(sid:ID!, amount:Int) : [OrderPosition] @cypher(statement:"MATCH (op:OrderPosition {sid:{sid}}) SET op.amount = {amount} RETURN op")

}

type QueryType {
    getOrderPosition(sid:ID!) : [OrderPosition] @cypher(statement:"MATCH (op:OrderPosition {sid: {sid}}) RETURN op")
}"""

        TestUtil.setup(schema)
        assertResult("""query { OrderPosition { amount } }""",
               mapOf("OrderPosition" to emptyList<Long>()))
    }
    @Test
    fun dynamicMutationConflictsWithAutoGenerated() {
        val schema = """
type Person {
    name: String
}
schema {
   mutation: MutationType
}
type MutationType {
    createPerson(name:String) : Person @cypher(statement:"CREATE (p:Person {name:\"Test\"+{name}}) RETURN p")
}
"""

        TestUtil.setup(schema)
        assertResult("""mutation { createPerson(name:"Jane") {name} }""",
        mapOf("createPerson" to mapOf("name" to "TestJane")))
    }
    @Test
    fun dynamicQueryConflictsWithAutoGenerated() {
        execute("CREATE (:Person {name:'Jane'}), (:Person {name:'John'})")
        val schema = """
type Person {
    name: String
}
schema {
   query: QueryType
}
type QueryType {
    Person(name:String) : Person @cypher(statement:"MATCH (p:Person {name:{name}}) RETURN p")
}
"""

        TestUtil.setup(schema)
        assertResult("""query { person(name:"Jane") {name} }""",
            mapOf("person" to mapOf("name" to "Jane")))
    }
    @Test
    fun dynamicQueryNullableValue() {
        execute("CREATE (:Person {name:'Jane'}), (:Person {name:'John'})")
        val schema = """
type Person {
    name: String
    label: String! @cypher(statement: "RETURN toLower(this.name) as label")
}
schema {
   query: QueryType
}
type QueryType {
    Person(name:String) : Person @cypher(statement:"MATCH (p:Person {name:{name}}) RETURN p")
}
"""

        TestUtil.setup(schema)
        assertResult("""query { person(name:"Jane") {name, label} }""",
                mapOf("person" to mapOf("name" to "Jane", "label" to "jane")))
    }

    @Test
    fun dynamicQueryNullValue() {
        execute("CREATE (:Person {name:'Jane'}), (:Person {name:'John'})")
        val schema = """
type Person {
    name: String
    nullable: String @cypher(statement: "RETURN null")
}
schema {
   query: Query
   mutation: Mutation
}
type Query {
    person(name:String) : Person @cypher(statement:"MATCH (p:Person {name:${'$'}name}) RETURN p")
}
type Mutation {
}
"""

        TestUtil.setup(schema)
        assertResult("""query { person(name:"Jane") {name, nullable} }""",
            mapOf("person" to mapOf("name" to "Jane", "nullable" to null)))
    }
}
